//   ,:.
//  (:::) Script
//   `-'
// Generated by GuavaScript (guavac) v0.1
// Last modified: 5/26/2016, 9:33:45 PM
var c = $("#main-canvas")[0], cg = c.getContext("2d");
var sidebarWidth = $("#main-sidebar").outerWidth();
var DEBUG = true;
var PRIMARY_BUTTON = 0, SCROLL_BUTTON = 1, SCROLL_MODIFIER = "alt", DELETE_MODIFIER = "shift";
var drawWidth = c.width, drawHeight = c.height, tileWidth = 0, tileHeight = 0, tileSize = 32, tileHalfSize = tileSize / 2, offsetX = 0, offsetY = 0, minVisTileX = 0, minVisTileY = 0, maxVisTileX = 0, maxVisTileY = 0, showHover = true, hoverTileX = -1, hoverTileY = -1, hoverConflict = false;
var tiles = {}, currentItem = null, currentAngle = 0;
function resize() {
	drawWidth = cg.canvas.width = window.innerWidth - sidebarWidth;
	drawHeight = cg.canvas.height = window.innerHeight;
	tileWidth = Math.floor(drawWidth / tileSize);
	tileHeight = Math.floor(drawHeight / tileSize);
	updateTileVisibility();
}
$(window).resize(function () {
	resize();
	draw();
});
function init() {
	resize();
	draw();
}
function iterTiles(callback) {
	for (var $$for_00000001$$ = 0; $$for_00000001$$ < _.keys(tiles).length; $$for_00000001$$++) {
		var key = _.keys(tiles)[$$for_00000001$$];
		if (callback(tiles[key])) {
			return true;
		}
	}
	return false;
}
function findTileKey(cond) {
	for (var $$for_00000002$$ = 0; $$for_00000002$$ < _.keys(tiles).length; $$for_00000002$$++) {
		var key = _.keys(tiles)[$$for_00000002$$];
		if (cond(tiles[key])) {
			return key;
		}
	}
	return null;
}
var bgColor = "#27A6CC", gridColor = "#9CE5FB", textColor = "#FFF";
var hoverColor = "rgba(0, 255, 150, 0.3)", hoverErrorColor = "rgba(255, 150, 150, 0.5)", powerColor = "rgba(100, 150, 255, 0.6)";
function draw() {
	cg.clearRect(0, 0, drawWidth, drawHeight);
	cg.beginPath();
	cg.fillStyle = bgColor;
	cg.fillRect(0, 0, drawWidth, drawHeight);
	cg.closePath();
	cg.fillStyle = bgColor;
	cg.fill();
	drawPower();
	drawGrid();
	drawTiles();
	if (showHover) {
		drawHoverHighlight();
	}
	if (DEBUG) {
		drawDebug();
	}
}
function drawGrid() {
	cg.beginPath();
	for (var x = offsetX % tileSize; x < drawWidth; x += tileSize) {
		if (x >= 0) {
			cg.moveTo(x, 0);
			cg.lineTo(x, drawHeight);
		}
	}
	for (var y = offsetY % tileSize; y < drawHeight; y += tileSize) {
		if (y >= 0) {
			cg.moveTo(0, y);
			cg.lineTo(drawWidth, y);
		}
	}
	cg.closePath();
	cg.strokeStyle = gridColor;
	cg.lineWidth = 2;
	cg.stroke();
}
function drawPower() {
	cg.fillStyle = powerColor;
	iterTiles(function (tile) {
		drawCenteredRange(tile.x, tile.y, tile.data);
	});
	cg.fill();
}
function drawCenteredRange(x, y, data, draw) {
	if (data.range > 1) {
		var left = x - data.range, top = y - data.range, width = data.width + data.range * 2, height = data.height + data.range * 2;
		cg.beginPath();
		cg.fillRect(left * tileSize + offsetX, top * tileSize + offsetY, width * tileSize, height * tileSize);
		cg.closePath();
		if (draw) {
			cg.fill();
		}
	}
}
function drawTiles() {
	iterTiles(function (tile) {
		if (tile.x + tile.width - 1 < minVisTileX || tile.x > maxVisTileX || tile.y + tile.height - 1 < minVisTileY || tile.y > maxVisTileY) {
			return;
		}
		var x = tile.x * tileSize + offsetX, y = tile.y * tileSize + offsetY, w = tile.data.width * tileSize, h = tile.data.height * tileSize;
		cg.translate(x + tileHalfSize, y + tileHalfSize);
		cg.rotate(tile.angle);
		if (tile.data.baseImage) {
			cg.drawImage(tile.data.baseImage, -tileHalfSize, -tileHalfSize, w, h);
		} else if (tile.data.image) {
			cg.drawImage(tile.data.image, -tileHalfSize, -tileHalfSize, w, h);
		} else {
			cg.beginPath();
			cg.fillRect(x, y, w, h);
			cg.closePath();
		}
		cg.setTransform(1, 0, 0, 1, 0, 0);
		if (tile.data.baseImage && tile.data.image) {
			var cx = x + tile.data.width * tileHalfSize - tile.data.image.width / 2, cy = y + tile.data.height * tileHalfSize - tile.data.image.height / 3 * 2;
			cg.save();
			cg.shadowOffsetX = 0;
			cg.shadowOffsetY = 0;
			cg.shadowColor = "white";
			cg.shadowBlur = 10;
			cg.drawImage(tile.data.image, cx, cy);
			cg.restore();
		}
	});
}
function drawHoverHighlight() {
	if (currentItem) {
		drawCenteredRange(hoverTileX, hoverTileY, currentItem, true);
		cg.fillStyle = hoverConflict ? hoverErrorColor : hoverColor;
		cg.beginPath();
		cg.fillRect(hoverTileX * tileSize + offsetX, hoverTileY * tileSize + offsetY, currentItem.width * tileSize, currentItem.height * tileSize);
		cg.closePath();
		cg.fill();
	}
}
function drawDebug() {
	cg.beginPath();
	cg.moveTo(offsetX, 0);
	cg.lineTo(offsetX, drawHeight);
	cg.closePath();
	cg.strokeStyle = "#FAA";
	cg.stroke();
	cg.beginPath();
	cg.moveTo(0, offsetY);
	cg.lineTo(drawWidth, offsetY);
	cg.closePath();
	cg.strokeStyle = "#AFA";
	cg.stroke();
	var xPad = 10, yPad = 10, textHeight = 11;
	cg.font = "11pt Verdana";
	cg.fillStyle = textColor;
	cg.strokeStyle = bgColor;
	cg.lineWidth = 3;
	var currentLine = 1;
	function drawTextLine(text) {
		var y = (yPad + textHeight) * currentLine;
		cg.strokeText(text, xPad, y);
		cg.fillText(text, xPad, y);
		currentLine += 1;
	}
	cg.beginPath();
	drawTextLine("Offset: (" + offsetX + ", " + offsetY + ")");
	drawTextLine("Tile size: " + tileSize);
	drawTextLine("Min vis tile: (" + minVisTileX + ", " + minVisTileY + ")");
	drawTextLine("Max vis tile: (" + maxVisTileX + ", " + maxVisTileY + ")");
	drawTextLine("Hovered tile: (" + hoverTileX + ", " + hoverTileY + ")");
	drawTextLine("Num tiles: " + _.size(tiles));
	cg.closePath();
	cg.stroke();
	cg.fill();
}
var pressed = false, scrollPressed = false, dragging = false, dragSensitivity = 3, mouseX = 0, mouseY = 0;
function tileActionInput(e) {
	if (e[DELETE_MODIFIER + "Key"]) {
		delTile(hoverTileX, hoverTileY);
	} else if (!hoverConflict) {
		setTile(hoverTileX, hoverTileY);
	}
}
c.onmousedown = function (e) {
	mouseX = e.pageX - c.offsetLeft;
	mouseY = e.pageY - c.offsetTop;
	if (e.button === 1 || e.button === 0 && e[SCROLL_MODIFIER + "Key"]) {
		scrollPressed = true;
	} else if (e.button === 0) {
		pressed = true;
	}
	if (pressed && !dragging) {
		tileActionInput(e);
		draw();
	}
};
c.onmouseup = function (e) {
	pressed = scrollPressed = false;
	dragging = false;
};
c.onmousemove = function (e) {
	newX = e.pageX - c.offsetLeft;
	newY = e.pageY - c.offsetTop;
	if (dragging) {
		if (pressed) {
			tileActionInput(e);
		} else if (scrollPressed) {
			offsetX += newX - mouseX;
			offsetY += newY - mouseY;
			updateTileVisibility();
		}
		mouseX = newX;
		mouseY = newY;
	} else if (pressed || scrollPressed) {
		var diffX = newX - mouseX, diffY = newY - mouseY;
		if (Math.sqrt(Math.pow(diffX, 2), Math.pow(diffY, 2)) >= dragSensitivity) {
			dragging = true;
			mouseX = newX;
			mouseY = newY;
			if (scrollPressed) {
				offsetX += diffX;
				offsetY += diffY;
			}
		}
		return;
	}
	hoverTileX = Math.floor((newX - offsetX) / tileSize);
	hoverTileY = Math.floor((newY - offsetY) / tileSize);
	hoverConflict = false;
	if (currentItem) {
		iterTiles(function (tile) {
			if (tile.overlapsTileData(hoverTileX, hoverTileY, currentItem)) {
				hoverConflict = true;
				return true;
			}
		});
	}
	draw();
};
$(c).mouseenter(function () {
	showHover = true;
	draw();
});
$(c).mouseleave(function () {
	showHover = false;
	draw();
});
$(c).mousewheel(function (e) {
	var zoomDist = e.deltaY;
	console.log(zoomDist);
});
$(window).keypress(function (e) {
	if (e.key === "r") {
		console.log("Rotating tile @ (" + hoverTileX + ", " + hoverTileY + ")");
		currentAngle += Math.PI / 2;
		if (currentAngle >= 2 * Math.PI) {
			currentAngle -= 2 * Math.PI;
		}
		var hoverTile = getTile(hoverTileX, hoverTileY);
		if (hoverTile && hoverTile.data.rotatable) {
			hoverTile.angle += Math.PI / 2;
			if (hoverTile.angle >= 2 * Math.PI) {
				hoverTile.angle -= 2 * Math.PI;
			}
			console.log("  New angle=" + hoverTile.angle);
			draw();
		} else {
			console.log("  No tile");
		}
	} else if (e.key === "q") {
		console.log("Clearing selected item");
		clearSelectedItem();
	}
});
function Tile(tileX, tileY, data) {
	this.x = tileX;
	this.y = tileY;
	this.angle = data.rotatable ? currentAngle : 0;
	this.data = data;
}
Tile.prototype.overlapsTile = function (x, y, w, h) {
	return this.x < x + w && this.x + this.data.width > x && this.y < y + h && this.y + this.data.height > y;
};
Tile.prototype.overlapsTileData = function (x, y, data) {
	return this.x < x + data.width && this.x + this.data.width > x && this.y < y + data.height && this.y + this.data.height > y;
};
function tileKey(tileX, tileY) {
	return tileX + "x" + tileY;
}
function setTile(tileX, tileY) {
	if (!currentItem) {
		console.error("Can't set tile: no item selected");
		return;
	}
	if (hoverConflict) {
		console.error("Can't set tile: overlap");
	}
	console.log("Setting tile @ (" + tileX + ", " + tileY + ")");
	console.log("  Image=" + currentItem.image);
	tiles[tileKey(tileX, tileY)] = new Tile(tileX, tileY, currentItem);
}
function getTile(tileX, tileY) {
	var key = tileKey(tileX, tileY);
	if (!tiles[key]) {
		key = findTileKey(function (tile) {
			if (tile.overlapsTile(tileX, tileY, 1, 1)) {
				return true;
			}
			return false;
		});
	}
	if (key) {
		return tiles[key];
	}
	return null;
}
function delTile(tileX, tileY) {
	console.log("Deleting tile @ (" + tileX + ", " + tileY + ")");
	delete tiles[tileKey(tileX, tileY)];
}
function clearTiles() {
	console.log("Clearing tiles");
	tiles = {};
}
function updateTileVisibility() {
	minVisTileX = Math.floor(-offsetX / tileSize);
	minVisTileY = Math.floor(-offsetY / tileSize);
	maxVisTileX = tileWidth + minVisTileX;
	maxVisTileY = tileHeight + minVisTileY;
}
var $items = $(".item");
$items.click(function () {
	var $this = $(this), active = $this.hasClass("active");
	console.log("Item clicked: active=" + active);
	clearSelectedItem();
	if (!active) {
		currentItem = getItemData($this);
		$this.addClass("active");
	}
});
function getItemData($item) {
	return {
		width: $item.data("width") || 1,
		height: $item.data("height") || 1,
		range: $item.data("range") || 1,
		image: $item.data("img") ? $("#" + $item.data("img"))[0] : $item.find("img")[0],
		baseImage: $item.data("base-img") ? $("#" + $item.data("base-img"))[0] : null,
		rotatable: $item.data("rotatable") || false
	};
}
function clearSelectedItem() {
	$items.removeClass("active");
	currentItem = null;
}
$("#option-debug").change(function () {
	DEBUG = this.checked;
	draw();
});
init();